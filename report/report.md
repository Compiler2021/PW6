# PW6 实验报告

> PB19020583 李晗驰
>
> PB19000002 孙策 
>
> PB19030888 张舒恒

## 问题回答

##### 思考题1-1：

针对`while`语句，LLVM IR代码会有十分明显的特点，可以将布局其分为四块，按顺序列出

1. `while`语句上文，以`br`指令无条件跳转到`while`语句的`bool`表达式块为结尾
2. `while`语句`bool`表达式部分，结尾`br`指令指明表达式判断为`true`和`false`分别要跳转到的代码块
3. `while`语句内部代码块部分，当第2部分判断为`true`，通过`br`指令跳转至此，结尾`br`指令无条件跳转到第2部分，即`while`语句`bool`表达式部分，这里的`br`指令内容很有意思，在下面展开回答
4. `while`语句下文，当第2部分判断为`false`，通过`br`指令跳转至此，控制流离开`while`语句执行部分，执行下文的程序。

以`demo`生成的`.ll`文件相关语句为例

```llvm
br label %14, !llvm.loop !4

!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.mustprogress"}
```

`!llvm.loop.*`是LLVM IR中的元数据(metadata)，由于LLVM IR没有表示loop的基本架构，所以使用元数据来表示loop，并以此可以进行包括控制流转移，变量增加固定数值等在内的一系列基础操作，而如何寻找loop中的最具代表性的指令来赋予元数据呢，最终选择了分支指令的最末尾，而这个元数据所对应的“序号”也恰好将不同的loop分隔开来，方便对程序运行的控制。

比如，新增一个`while`语句，我们出了在两个`while`的结尾`br`指令发现一个元数据外，还会在`.ll`文件的末尾看到如下代码:

```llvm
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.mustprogress"}
!6 = distinct !{!6, !5}
```

显然`!4`和`!6`区分了两个`while`语句，又由于他们都是`while`语句，因此都要执行`!5`操作

同样的对`for`语句，可能看到这种:

```llvm
br i1 %exitcond, label %._crit_edge, label %.lr.ph, !llvm.loop !0

!0 = distinct !{ !0, !1 }
!1 = !{ !"llvm.loop.unroll.count", i32 4 }
```

`!1`也包含一种对应的操作。

##### 思考题1-2：

举例说明，`func_hand.ll`使用的函数调用语句为：

```llvm
%6 = call i32 @add(i32 %4, i32 %5)  ; funcall ret add(a, b)
```

其中使用指令为`call`，指令后指明函数返回参数的类型，再往后则指定对应的函数，以及要传入的实参。

传入实参部分要指明参数的类型和来源变量。

函数返回是什么类型，则等号左边的数据就会是对应类型，在这个例子中，类型为`i32`。

直接调用`%6`就可以进行计算和操作，不过针对`demo`中类似的部分，如果有`a = call(c,d)`之类的操作，会将`%6`存入到“分配”给`a`的变量中，将返回值绑定到`a`参数

## 实验设计

## 实验难点及解决方案

## 实验总结

## 实验反馈

## 组间交流


